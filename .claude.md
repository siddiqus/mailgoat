# Claude Code Instructions

This file contains project-specific guidelines and best practices for development. Claude Code will follow these instructions when working on this codebase.

## Package Manager

**Always use `yarn` instead of `npm` for all package management operations.**

Examples:
- Install dependencies: `yarn install` or `yarn`
- Add package: `yarn add <package-name>`
- Add dev dependency: `yarn add -D <package-name>`
- Remove package: `yarn remove <package-name>`
- Run scripts: `yarn dev`, `yarn build`, `yarn test`

## Testing Requirements

**Always write unit tests for new features and bug fixes.**

- Write tests for all new components, hooks, and utility functions
- Place test files adjacent to the code they test (e.g., `Component.jsx` → `Component.test.jsx`)
- Use the existing testing setup: Vitest, React Testing Library, and Jest DOM
- Aim for meaningful test coverage focusing on:
  - Component rendering and user interactions
  - Edge cases and error handling
  - Business logic and data transformations
  - API calls and service functions
- Run tests before committing: `yarn test:run`
- Use descriptive test names that explain what is being tested

Example test structure:
```javascript
describe('ComponentName', () => {
  it('should render correctly with valid props', () => {
    // Test implementation
  })

  it('should handle user interaction', () => {
    // Test implementation
  })

  it('should handle error states', () => {
    // Test implementation
  })
})
```

## Code Organization & Architecture

### Component Segmentation

**Implement clean code with small to medium-sized components.**

- Keep components focused on a single responsibility
- Break down large components into smaller, reusable pieces
- Typical component size: 100-250 lines of code
- If a component exceeds ~300 lines, consider refactoring
- Extract repeated UI patterns into separate components
- Use composition over large monolithic components

Example of good segmentation:
```
src/pages/SendEmail.jsx (main page)
  ├── src/components/TemplateSelector.jsx
  ├── src/components/ParameterForm.jsx
  ├── src/components/EmailPreview.jsx
  └── src/components/RecipientInput.jsx
```

### Separation of Concerns

**Separate business logic and API calls from UI components.**

1. **UI Components** (`src/components/`, `src/pages/`)
   - Focus on presentation and user interaction
   - Should be as "dumb" as possible
   - Receive data and callbacks via props
   - Minimal business logic

2. **Custom Hooks** (`src/hooks/`)
   - Encapsulate stateful logic and side effects
   - Reusable across components
   - Handle data fetching, form state, etc.
   - Examples: `useTemplates()`, `useEmailValidation()`

3. **Service Files** (`src/services/`)
   - Pure business logic and data transformations
   - API calls and external integrations
   - No React dependencies (hooks, state, etc.)
   - Easily testable in isolation

4. **Utilities** (`src/utils/`)
   - Pure functions for data manipulation
   - Validators, formatters, helpers
   - No side effects

Example structure:
```javascript
// ❌ Bad - Everything in component
function EmailForm() {
  const [data, setData] = useState([])

  useEffect(() => {
    fetch('/api/templates')
      .then(res => res.json())
      .then(setData)
  }, [])

  // ... more logic and UI
}

// ✅ Good - Separated concerns
// hooks/useTemplates.js
export function useTemplates() {
  const [templates, setTemplates] = useState([])
  const [loading, setLoading] = useState(false)

  useEffect(() => {
    loadTemplates()
  }, [])

  async function loadTemplates() {
    setLoading(true)
    const data = await templateService.getAll()
    setTemplates(data)
    setLoading(false)
  }

  return { templates, loading, refresh: loadTemplates }
}

// components/EmailForm.jsx
function EmailForm() {
  const { templates, loading } = useTemplates()

  return (
    // ... clean UI code
  )
}
```

## File Organization

```
src/
├── components/        # Reusable UI components
├── pages/            # Page-level components (routes)
├── hooks/            # Custom React hooks
├── services/         # Business logic & API calls
├── utils/            # Pure utility functions
├── repositories/     # Data access layer
└── __tests__/        # Shared test utilities (if needed)
```

## Code Quality Standards

- **DRY Principle**: Don't repeat yourself - extract common logic
- **Single Responsibility**: Each function/component does one thing well
- **Descriptive Naming**: Use clear, self-documenting names
- **Error Handling**: Always handle errors gracefully
- **TypeScript/JSDoc**: Consider adding JSDoc comments for complex functions
- **Linting**: Run `yarn lint:fix` before committing
- **Formatting**: Code is auto-formatted with Prettier via Husky pre-commit hook

## Git Workflow

- Write clear, descriptive commit messages
- Follow conventional commits format when possible
- Run `yarn lint` and `yarn test:run` before committing
- Husky pre-commit hooks will automatically run lint and format

## Additional Guidelines

- **Accessibility**: Use semantic HTML and ARIA labels where appropriate
- **Performance**: Memoize expensive computations, avoid unnecessary re-renders
- **Security**: Sanitize user input, validate data, avoid XSS vulnerabilities
- **User Experience**: Provide loading states, error messages, and feedback
- **Documentation**: Add comments for complex logic, update README when needed

## Common Patterns in This Project

1. **Repository Pattern**: Data access is abstracted through repository classes
   - Example: `LocalStorageSettingsRepository`, `LocalStorageTemplateRepository`

2. **Service Layer**: Business logic is in service files
   - Example: `emailService.js`, `templateService.js`, `fileParsingService.js`

3. **Validation**: Use dedicated validator utilities
   - Example: `emailValidator.js`, `templateValidator.js`

4. **Sanitization**: Always sanitize HTML before rendering
   - Use: `sanitizeHtml()` from `utils/sanitizer.js`

## When Adding New Features

1. **Plan the structure** - Identify components, hooks, and services needed
2. **Write tests first** (TDD) or immediately after implementation
3. **Implement in layers**:
   - Services/utilities (pure logic)
   - Hooks (stateful logic)
   - Components (UI)
4. **Test thoroughly** - Unit tests, integration tests, manual testing
5. **Review code** - Check for code quality, separation of concerns
6. **Update documentation** - README, comments, this file if needed

## Questions or Clarifications?

If unclear about any architectural decision or best practice, ask before implementing. Consistency with existing patterns is important.
